Index: app/src/main/java/com/m2dl/challengemobe/GameView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.m2dl.challengemobe;\r\n\r\nimport android.content.Context;\r\nimport android.content.SharedPreferences;\r\nimport android.content.res.Resources;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.Paint;\r\nimport android.graphics.Point;\r\nimport android.graphics.Rect;\r\nimport android.graphics.RectF;\r\nimport android.util.DisplayMetrics;\r\nimport android.view.SurfaceHolder;\r\nimport android.view.SurfaceView;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.core.graphics.ColorUtils;\r\n\r\nimport java.util.Date;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Random;\r\n\r\nimport static java.lang.Math.cos;\r\nimport static java.lang.Math.sin;\r\n\r\npublic class GameView extends SurfaceView implements SurfaceHolder.Callback {\r\n    private GameThread thread;\r\n    private GameActivity context;\r\n    private Canvas canvas;\r\n    private double inclinaison;\r\n    private int contextHeight;\r\n    private int contextWidth;\r\n    private SharedPreferences sharedPref;\r\n    private int bgXPosition = 0;\r\n    private Bitmap bitmap;\r\n    private int bgHeight;\r\n    private int bgWidth;\r\n    private int bgFullWidth;\r\n    private Date lastDrawDate;\r\n    double vitesse = 1.2; // 12 km/h\r\n\r\n    public static int OBSTACLE_HEIGHT = 100;\r\n    private List<Birds> obstacles;\r\n\r\n\r\n    private float x0 = 100;\r\n    private float y0;\r\n    private float backgroundX;\r\n    private float backgroundY;\r\n    private float a;\r\n    private float t;\r\n    private float v0;\r\n    private float g;\r\n\r\n    public GameView(GameActivity context) {\r\n        super(context);\r\n        this.context = context;\r\n        setFocusable(true);\r\n        getHolder().addCallback(this);\r\n        this.sharedPref = context.getPreferences(Context.MODE_PRIVATE);\r\n        DisplayMetrics displayMetrics = new DisplayMetrics();\r\n        context.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);\r\n        contextHeight = displayMetrics.heightPixels + getNavigationBarHeight(context);\r\n        contextWidth = displayMetrics.widthPixels;\r\n\r\n        initBackground();\r\n        lastDrawDate = new Date();\r\n\r\n        obstacles = new ArrayList<>();\r\n        createRandomObstacle();\r\n        createRandomObstacle();\r\n\r\n\r\n        x0 = 100;\r\n        y0 = contextHeight / 2;\r\n        g = 0.5f;\r\n        a = (float) (Math.PI / 4);\r\n        v0 = 25;\r\n\r\n    }\r\n\r\n    private void initBackground() {\r\n        bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.background);\r\n        bgHeight = (bitmap.getHeight()) / 2;\r\n        bgWidth = (bitmap.getWidth()) / 3;\r\n        bgFullWidth = bitmap.getWidth();\r\n    }\r\n\r\n    private int getNavigationBarHeight(GameActivity context) {\r\n        DisplayMetrics metrics = new DisplayMetrics();\r\n        context.getWindowManager().getDefaultDisplay().getMetrics(metrics);\r\n        int usableHeight = metrics.heightPixels;\r\n        context.getWindowManager().getDefaultDisplay().getRealMetrics(metrics);\r\n        int realHeight = metrics.heightPixels;\r\n        if (realHeight > usableHeight)\r\n            return realHeight - usableHeight;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    public GameThread getThread() {\r\n        return thread;\r\n    }\r\n\r\n    @Override\r\n    public void surfaceCreated(@NonNull SurfaceHolder holder) {\r\n        thread = new GameThread(getHolder(), this);\r\n        thread.setRunning(true);\r\n        thread.start();\r\n    }\r\n\r\n    @Override\r\n    public void surfaceChanged(@NonNull SurfaceHolder holder, int format, int width, int height) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void surfaceDestroyed(@NonNull SurfaceHolder holder) {\r\n        boolean retry = true;\r\n        while (retry) {\r\n            try {\r\n                thread.setRunning(false);\r\n                thread.join();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            retry = false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void draw(Canvas canvas) {\r\n        super.draw(canvas);\r\n        if (canvas != null) {\r\n            Date d = new Date();\r\n            long tempsPasse = (d.getTime() - lastDrawDate.getTime()) / 10;\r\n            lastDrawDate = d;\r\n            drawBackground(canvas, tempsPasse);\r\n\r\n\r\n            Paint paint = new Paint();\r\n            paint.setColor(Color.rgb(0, 0, 0));\r\n\r\n            calculTrajectoire();\r\n            canvas.drawCircle(backgroundX, backgroundY, 50, paint);\r\n\r\n            paint.setColor(Color.rgb(0, 0, 0));\r\n            // canvas.drawCircle(circlePosition.x, circlePosition.y, 100, paint);\r\n        }\r\n    }\r\n\r\n    private void drawBackground(Canvas canvas, long tempsPasse) {\r\n        if (bgXPosition >= bgFullWidth - bgWidth) bgXPosition = 0;\r\n        bgXPosition = bgXPosition + (int) (tempsPasse * vitesse);\r\n        Rect srcRectForRender = new Rect(bgXPosition, bgHeight, bgXPosition + bgWidth, bgHeight * 2);\r\n        Rect dstRectForRender = new Rect(0, 0, contextWidth, 800);\r\n        canvas.drawBitmap(bitmap, srcRectForRender, dstRectForRender, null);\r\n    }\r\n\r\n    public void createRandomObstacle() {\r\n        Random rand = new Random();\r\n        int posy = rand.nextInt(contextHeight - OBSTACLE_HEIGHT) + OBSTACLE_HEIGHT;\r\n        Point obstaclePoint = new Point(contextWidth - OBSTACLE_HEIGHT, posy);\r\n        obstacles.add(new Birds(obstaclePoint, randomBird()));\r\n    }\r\n\r\n\r\n    //A modifier en fonction de la position du background\r\n    public void drawAllObstacles(Canvas canvas) {\r\n\r\n\r\n        for (Birds obstacle : obstacles) {\r\n            //modifier aussi le y en fonction du background\r\n            obstacle.getP().x = obstacle.getP().x - 10;\r\n            System.out.println(\"x=\" + obstacle.getP().x);\r\n            if (obstacle.getP().x <= 0) {\r\n\r\n                obstacles.remove(obstacle);\r\n                System.out.println(\"Obstacle removed\");\r\n            }\r\n            Paint myPaint = new Paint();\r\n            myPaint.setColor(Color.rgb(0, 0, 0));\r\n            myPaint.setStrokeWidth(10);\r\n\r\n            canvas.drawBitmap(obstacle.getB(), obstacle.getP().x, obstacle.getP().y, myPaint);\r\n\r\n        }\r\n    }\r\n\r\n\r\n    public void calculTrajectoire() {\r\n        backgroundX = (float) (cos(a) * v0 * t + x0);\r\n        backgroundY = (float) ((-0.5) * g * t * t + sin(a) * v0 * t + y0);\r\n        //y = contextHeight - y;\r\n        t = t + 0.25f;\r\n    }\r\n\r\n    public void setInclinaison(double inclinaison) {\r\n        this.inclinaison = inclinaison;\r\n    }\r\n\r\n    public Bitmap randomBird() {\r\n        Resources res = getResources();\r\n        Bitmap bitmap = null;\r\n        Random rn = new Random();\r\n        int answer = rn.nextInt(3) + 1;\r\n        System.out.println(answer);\r\n        if (answer == 1) {\r\n            bitmap = BitmapFactory.decodeResource(res, R.drawable.birdpink);\r\n        }\r\n        if (answer == 2) {\r\n            bitmap = BitmapFactory.decodeResource(res, R.drawable.birdblue);\r\n        }\r\n        if (answer == 3) {\r\n            bitmap = BitmapFactory.decodeResource(res, R.drawable.birdbrown);\r\n        }\r\n        Bitmap resized = Bitmap.createScaledBitmap(bitmap, 150, 150, true);\r\n        return resized;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/m2dl/challengemobe/GameView.java	(revision 61b1fb74b3d39f6897107720defc4a7e052046f7)
+++ app/src/main/java/com/m2dl/challengemobe/GameView.java	(date 1616161471497)
@@ -156,7 +156,7 @@
         if (bgXPosition >= bgFullWidth - bgWidth) bgXPosition = 0;
         bgXPosition = bgXPosition + (int) (tempsPasse * vitesse);
         Rect srcRectForRender = new Rect(bgXPosition, bgHeight, bgXPosition + bgWidth, bgHeight * 2);
-        Rect dstRectForRender = new Rect(0, 0, contextWidth, 800);
+        Rect dstRectForRender = new Rect(0, 0, contextWidth, contextHeight);
         canvas.drawBitmap(bitmap, srcRectForRender, dstRectForRender, null);
     }
 
